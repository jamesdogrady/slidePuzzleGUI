#include <iostream>
#include <fstream>
#include <string>
#ifndef TARGET_OS_MAC
#include <cstring>
#endif
#include "slidePuzzle.h"
#include <array>
#include <vector>
#include <unistd.h>
#include <list>
#include <limits>
#include "spdlog/spdlog.h"
#include "spdlog/sinks/basic_file_sink.h"
// how users inputs blank value and how we print it out.
// how it's represented in the puzzle.
// zero won't work because its end of string.
/* this program solves a slide puzzle, for instance given in microsoft rewards.
 * The puzzle has a rectangular grid with one blank space.  The remaining
 * spaces are part of a scrambled picture.  The goal is to move one tile at a
 * time into the blank space in the puzzle so that the picture is as expected.
 * So, lets say a starting configuration of a 3x3 puzzle is 
 * 8 5 2
 * 3  4 Blank
 * 5 6 1 
 *  the goal is to make a series of moves such that the result is
 * 1 2 3 
 * 4 5 6
 * 7 8 Blank.
 * Each move is a swap of Blank for some adjacent vertical or horizontal move,
 * so, in the above example, 2 or 4 can be swapped for Blank.  If two is
 * swapped
 * swapped,  you get 8 5 Blank
 * 		     3 4 2
 * 		     5 6 1
 *
 * The program takes two arguments, -x and -y which specified an x and y
 * dimension.  Then, it takes the starting configuration with "B" for blank
 * so for the above example, slidePuzzle -x 3 -y 3 8 5 2 3 4 B 5 6 1
 * 
 * The program works by adding a starting configuration to a list.
 * the list is traversed and for each configuration in the list, new
 * configurations are generated by adding legal moves based on where the B is
 * in the puzzle.  These configurations are added to a second list.  Each legal
 * configuration is saved in a data structure, so when a configuration is
 *  found, if moves have not been added yet, it's added to a second list.
 * when the first list is done, the next interation is for the second list of
 * what we found new the last time. This continues until the final puzzle
 * Configuration  is found, or no more configurations are left.
 * Note that each iteration though a list is one more move away from the
 * starting postion, any configuration, including the final configuration is
 * reached for the first time in the smallest number of moves.n  Thus, we can
 * end the first time we find a final configuration.
 */
// class representing a puzzle coordinate.
Coord::Coord(int x,int y) {
	this->x=x;
	this->y = y;
}


// std::vector<std::vector<std::list<Coord> > > Puzzle::moves = std::vector<std::vector<std::list<Coord> > >(0);
// final configuration.

// class for a specific puzzle configuration.
// puzzle contents are in a character array.
// which  show how you move from the starting posistion to the ending position.


PuzzleConfig::PuzzleConfig( int x,int y): blank(0,0) {
		this->xSize=x;
		this->ySize=y;
	
		this->final=false;
		contents = (unsigned char *) malloc(xSize*ySize);
		this->blank = Coord(0,0);
	}

PuzzleConfig::~PuzzleConfig() {
		free (contents);
	}


// create a new PuzzleConfig object, containing the state of the puzzle after the move.
// move contains a coordinate in the puzzle that we are moving the blank to, thus swapping blank and the
// value in move.  In addition, PuzzleConfig has a list of moves that get us from the starting configuration
// to this configuration, so add the move to that list
// lets say move has (0,0) and the puzzle looks like 9 B 5 .... the new configuration will have B 9 5 ... and
// movelist will end with (0,0).
PuzzleConfig::PuzzleConfig(PuzzleConfig *oPuzzle,Coord move)  :blank(0,0) {
		// copy puzzleContents
		// all puzzle configs have this value.
		this->final=false;
		this->xSize=oPuzzle->xSize;
		this->ySize=oPuzzle->ySize;
		// copy contents to the new object
		contents = (unsigned char *) malloc(xSize*ySize);
		memcpy( this->contents, oPuzzle->contents,this->xSize * this->ySize);

		// swap blank and move.
		int val = this->getVal(move);
		this->add(val,oPuzzle->blank);
		
		this->setBlank(move);
		// copy movelist and add a move specified by move.
		std::list<Coord>::iterator it;
		for ( it= oPuzzle->moveList.begin();it != oPuzzle->moveList.end();it++ ) {
			this->moveList.push_back(*it);
		}
		this->moveList.push_back(move);
		
}

// update the value at coord with val
void PuzzleConfig::add(int val,Coord c) {
		this->contents[c.x*this->xSize+c.y] = val;
	}

// get the value at this location.
int PuzzleConfig::getVal(Coord c) {
		return(this->contents[c.x*this->xSize+c.y]);
}

// set the blank for this puzzle.
void PuzzleConfig::setBlank(Coord c) {
		add(SlidePuzzle::BLANK_VAL,c);
		this->blank= c;
}
void PuzzleConfig::setVerbose(bool val ) {
	verbose=val;
}
// comapre two puzzle configuations.  We only care about the contents not the movelist.  
// if they match, we've already found a way to get to this configuation with the same or fewer moves so the movelist 
// doesn't matter.

bool PuzzleConfig::compare(PuzzleConfig *otherConfig) {
		if ( memcmp(this->contents, otherConfig->contents,xSize * ySize) == 0 )  {
			return true;
		}
		return false;
}

// print the results
void PuzzleConfig::print( bool detail ) {
	std::stringstream outStr;
		for ( int i=0;i<ySize*xSize;i++ ) {
			unsigned char val = this->contents[i];
			// std::cout << "Puzzle Val" <<  val << " Index " << i << std::endl;	
			if ( val == SlidePuzzle::BLANK_VAL) {
				outStr << " " <<   SlidePuzzle::BLANK_CHAR;
			} else {
				outStr << " " << std::dec  <<   (unsigned int ) val;
			}
		}
		outStr << std::endl;
		if ( detail ) {
			outStr <<  " " <<  this->blank.x <<  " " << this->blank.y <<  std::endl;
			outStr <<  " " <<  this->moveList.size()   <<  std::endl;
		}
	spdlog::debug(outStr.str());
		
};

std::ostream& operator<<(std::ostream& os, const PuzzleConfig & obj) {
	for ( int i=0;i<obj.ySize*obj.xSize;i++ ) {
		int val = obj.contents[i];
		if ( val == SlidePuzzle::BLANK_VAL) {
			os << " " << SlidePuzzle::BLANK_CHAR;
		} else {
			os << " " << val;
		}
	}
	if ( obj.verbose ) {
		os << " " << obj.blank.x << " " << obj.blank.y ;
		os << " " << obj.moveList.size()  ;
	}
	os << std::endl;
	return os;
		
};




// class representing the static infomration about the puzzle, e.g. the size
// and  what moves are legal given the location of a blank in the puzzle.
//  we'll also have a list of puzzleConfigs that you can get to from the starting state.
SlidePuzzle::SlidePuzzle ( int x, int y ) {
		this->xDim=x;
		this->yDim=y;
		this->size=xDim*yDim;
		this->debug=false;
		this->verbose=false;
		this->debug_lvl=0;
		this->valid= false;
		// there is one 
		this->size = (x * y) ;
		// now we know the dimensions of moves so we can initialize it.
		// moves.  If there is a blank at square (x,y) what squares can get the blank after a move.
		// If there is a blank at square (0,0), the blank can move to either square (0,1) or square (1,0)
		// moves is a two dimensional vector with a list of moves (coordinates) for that square.
		this->moves = std::vector<std::vector<std::list<Coord> > >(x);
		for ( int i=0;i<x;i++) {
			this->moves[i] = std::vector<std::list<Coord> >(y);
			for ( int j=0;j<y;j++) {
				// if the Blank is not in the first cololm moving right is ok
				if ( j>0 ) {
					this->moves[i][j].push_back(Coord(i,j-1));
				} 
				// if the blank is not in the last column, moving left is ok
				if ( j != (y-1)  ) {
					this->moves[i][j].push_back(Coord(i,j+1));
				}
				// if the blank i snot in the first row, you can move up
				if ( i>0 ) {
					this->moves[i][j].push_back(Coord(i-1,j));
				} 
				// if the blank is not in the last row, you can move down.
				if ( i != (x-1) ) {
					this->moves[i][j].push_back(Coord(i+1,j));
				}
			}
		}
		// in order to explore the square, we need to keep track of what we've found so far.
		// To make this more efficient, use a two dimensional vector with a list of puzzleConfigutions
		// The vector indexes are the first two characters of contents.
		// Here, we just initialize the lists to empty.
		this->allConfigs = std::vector< std::vector<std::list <PuzzleConfig * > > > (this->size+1 );
		for ( int i=0;i<this->size+1;i++ ) {
			this->allConfigs[i] = std::vector<std::list <PuzzleConfig * > > (size +1 );
			for ( int j=0;j<this->size+1;j++ ) {
				this->allConfigs[i][j]  = std::list< PuzzleConfig *>() ;
	
			}
		}
		// for the dimensions of the puzzle, we know the end goal so set this up.
		this->setFinalContents();
		// gotVal is used to validate the puzzle once, the squares are set up.
		for ( int i=0;i<9;i++ )  {
			gotVal[i]=false;
		}
		this->valid = true;
		this->startConfig = new PuzzleConfig(x,y);

}
// puzzle squares will start with 1 and end with x*y-1 and a blank.
void SlidePuzzle::setFinalContents() {
			finalContents = (unsigned char *) malloc(this->size);
			for ( int i=0;i<xDim*  yDim-1;i++) { 
				finalContents[i] = (unsigned char) i+1;
			}
			finalContents[size-1] = (unsigned char) SlidePuzzle::BLANK_VAL;
}
// add the configuration to the proper allConfigs vector.
void SlidePuzzle::add(PuzzleConfig *config) {
	unsigned char c1,c2;
	c1=config->contents[0];
	c2=config->contents[1];
	// however we represent BLANK_VAL in contents, it's index 0 in allConfigs.
	if ( c1 == SlidePuzzle::BLANK_VAL ) {
		c1=0;
	}
	if ( c2 == SlidePuzzle::BLANK_VAL ) {
		c2=0;
	}

	allConfigs[c1][c2].push_back(config);
}
void SlidePuzzle::setDebug(int _lvl, bool _verbose) {
	verbose=_verbose;
	debug_lvl= _lvl;
	if ( debug_lvl > 0 ) {
		debug=true;
	} else {
		debug=false;
	}
}
// search allConfigs for a match to config.
bool SlidePuzzle::search(PuzzleConfig *config ) {
		std::list<PuzzleConfig *>::iterator it;
		std::list<PuzzleConfig *> *list;
		unsigned char c1,c2;
		c1=config->contents[0];
		c2=config->contents[1];
		// for searching, convert BLANK_VAL to 0;
		// Do this in case we change it later.  Here, we have to index an array so we have to use 0.
		if ( c1 == SlidePuzzle::BLANK_VAL ) {
			c1=0;
		}
		if ( c2 == SlidePuzzle::BLANK_VAL ) {
			c2=0;
		}
		list = &(allConfigs[c1][c2]);


		for ( it = list->begin();it!=list->end();++it) {
			if ( config->compare(*it) ) {
				return(true);
			}
		}
		return(false);
}
// explore is the function that looks for solutions to the puzzle.
// It can be called with oneLoop set to true which solve the whole puzzle in one call to explore
// or oneLoop set to false, in which case, it will run one loop and exit.
// first is set to true for the first invocation.
// for GUI use, doing one loop per call will allow for a cancel button to work better.
// exploreList is a list of puzzleConfig objects to explore.  addedList is the list of puzzleConfig
// objects we've found during the loop.  At the end of each loop, exploreList is set to addedList and addedList is 
// cleared.
// The loop consists of generating new puzzleConfig objects for each possible move from the exploreList puzzleConfigs.
// Once a new puzzleConfig is found, we search to see if we've already seen this configuation.  If we've seen it,
// we don't need to process it.  If we haven't seen it, we see if this is a soltuion to the puzzle.  if it is a 
// solution, we note that and stop.  Otherwise, the new configuration is added to addedList
// We are done when we find a solution or we don't add anything else to the exploreList because we've seen 
// all configuations of the puzzle already ( so there is no solution).
// For oneLoop invocation, the function returns true if we finished exploring or false if we should keep going
// For oneLoop=false, true means a solution is found and false means no solution was found.
//
//
bool SlidePuzzle::explore(bool first, bool oneLoop ) {
		// the confiigList is every position we've found so far.  Go through
		// list and generate the next moves.  Keep going until we don't add
		// anything else 
		// listOne and listTwo are pointed to by addedList and exploreList.
		static std::list<PuzzleConfig *> listOne;
		static std::list <PuzzleConfig *> listTwo;
		// use pointers for these lists as they switch back and forth during the loop invocation.
		static std::list <PuzzleConfig *> *addedList,*exploreList;
		// initialize for the first invocation.
		if (first ) {
			// initially, exploreList will just contain the starting configuration
			spdlog::debug("Push Back startConfig");
			listOne.push_back(startConfig);
			if ( debug ) {
				startConfig->print(true);
			}
			// initialize the pointers
			exploreList=&listOne;
			addedList=&listTwo;
		}
		// set up the object to hold what we've encountered so far.
		// iterator for explore list
		std::list<PuzzleConfig *>::iterator it;
		int dupConfig =0;
		spdlog::debug("explore loop");
		do {
			if ( debug  ) {
				spdlog::debug("Starting explore loop {0} {1}",exploreList->size(), dupConfig);
			}
			dupConfig =0;
			// iterate through explorelist
			for ( it = exploreList->begin();it != exploreList->end();++it) {
				// generate moves for this configuration
				int blankX = (*it)->blank.x;
				int blankY = (*it)->blank.y;
				// iterator for legal moves
				std::list<Coord>::iterator it2;;
				// iterate through the possible list of moves from (blankX,blankY);
				for ( it2= moves[blankX][blankY].begin();it2 != moves[blankX][blankY].end();it2++ ) {
					// for each legal move, generate the next configurations.
					// newPuzzleConfig based on the config we are exploring (*it) and a move
					// coordiate(*it2)
					PuzzleConfig *newPuzzleConfig = new PuzzleConfig((*it),*(it2));
					// have we seen this before.
					//
					if ( search(newPuzzleConfig))  {
					// since we've seen this before, delete the objeÃ§t.  We don't need to
					// process this further
						delete(newPuzzleConfig);
						dupConfig++;
					} else {
						// we found a new configuration so add it to addedList for next iteration
						addedList->push_back(newPuzzleConfig);
						// and add it to everything seen so far
						add(newPuzzleConfig);
						// the first time we find the final  configuration, we've found the
						// the best path
						// checking to see if this is the solution to the puzle.
						if ( memcmp(newPuzzleConfig->contents,finalContents,size ) == 0 ) {
							newPuzzleConfig->final = true;
						}
						// we've finished.
						if ( newPuzzleConfig->final ) {
							spdlog::debug("explore solution found");
							// put the solution into resultsString
							printFinalConfig(newPuzzleConfig,startConfig);
							return(true);
						}
					}
				}
			}
			// now empty the exploreList and switch.
			// on the next iteration of the loop, exploreList is the
			// addedList and addedList is empty
			std::list <PuzzleConfig *> *tempList;
			exploreList->clear();
			tempList = exploreList;
			exploreList = addedList;
			addedList = tempList;
	} while (   ! oneLoop &&  exploreList->size() > 0 ) ;
	if ( oneLoop ) {
		if ( exploreList->size() > 0 ) {
			// we have another loop to run at least.
			return false;
		} else {
			spdlog::debug("explore No solution found");
			return true;
		}
	}
	// if oneLoop is false, we did find a solution and we are done.
	return(false);
};

// printing the final configuration results go to resultsString
void SlidePuzzle::printFinalConfig ( PuzzleConfig * finalConfig,PuzzleConfig *startConfig,bool verbose)
{
	std::list<Coord>::iterator it;
	//found a match
	resultsString << "Solution Found" << std::endl;
	resultsString  << "Moves from start " << std::endl;
	int mvCnt=1;
	PuzzleConfig *currentStep = startConfig;
	PuzzleConfig *nextStep ;
	if ( verbose ) {
		finalConfig->setVerbose(true);
	}
	for ( it= finalConfig->moveList.begin();it != finalConfig->moveList.end();it++ ) {
		resultsString << std::dec << mvCnt << " (" << (*it).x+1 << ", " << (*it).y+1<<  ")"  ;
		mvCnt++;
		nextStep=new PuzzleConfig(currentStep,(*it));
		if ( verbose ) {
			resultsString << *nextStep;
		}
		currentStep=nextStep;
		// the print prints the std::endl;
		// std::cout << std::endl;
	}	
	spdlog::debug("Solution String [[{0}]",resultsString.str());
}

// accessor for results
std::string SlidePuzzle::getResults() {
	return( resultsString.str());
}

// accessor for error
std::string SlidePuzzle::getErrorString() {
	return (errorString.str());
}

// set the initial value of the puzzle.
// we do checking here to detect errors like value specified twice.  For errors, errorSting is set and valid isset to // false.
bool SlidePuzzle::setInitialVal(int x,int y, int val ) {
	int lastVal = 8;
	std::string valStr;
	unsigned char nVal=val;
	if ( nVal == SlidePuzzle::BLANK_VAL ) {
		nVal=0;
	}
	if ( nVal < 0 || nVal > lastVal  ) {
		errorString <<  " value out of range";
		return (false);
	}
	if ( gotVal[nVal]  ) {
		// value specified twice.
		if ( nVal == 0 ) {
			valStr="Blank";
		} else {
			valStr =   std::to_string(val);
		}
		errorString << valStr << " already specified" << std::endl;
		valid=false;
		return (false);
	}
	gotVal[nVal] = true;
	if ( val == SlidePuzzle::BLANK_VAL ) {
		startConfig->setBlank(Coord(x,y));
	} else {
		startConfig->add(val,Coord(x,y));
	}
	return(true);
}

// once all values are set for the puzzle, check for value not specified.
// once again, valid is set to false and errorString is updated.
bool SlidePuzzle::checkPuzzle() {
	bool puzzleError = false;
	for ( int i=0;i<9;i++ ) {
		if ( ! gotVal[i] ) {
			puzzleError =  true;
			valid=false;
			errorString << "" << std::to_string(i) <<  " Not found in puzzle" << std::endl;
		}
	}
	return ( puzzleError);
}


